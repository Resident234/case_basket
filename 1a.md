1a

Для демонстрации я записал видео (https://www.youtube.com/watch?v=YVPmHCWGxLg&feature=youtu.be).


Условие задачи я интерпретировал так:
1) Сортируем все товары в корзине по возрастанию цены
2) Первым ceil(количество товаров в корзине / N) делаем стоимость Х

Используем обработчку событий.
Задействуется только один файл - handler.php , который через require_once подключён в init.php

Используется тандем из событий OnSaleBasketSaved модуля sale и OnGetOptimalPrice модуля catalog.

`$eventManager = \Bitrix\Main\EventManager::getInstance();
$eventManager->addEventHandler(
    'sale',
    'OnSaleBasketSaved',
    array('ChangeBasketClass', "OnSaleBasketSavedHandler")
);

$eventManager->addEventHandler(
    'catalog',
    'OnGetOptimalPrice',
    array('ChangeBasketClass', "OnGetOptimalPriceHandler")
);`

#Схема работы указанных событий во время пользовательских действий.
Пользователь меняет количество товара:
1) OnGetOptimalPrice для того товара, у которого меняется количество. Наш код никакие действия не выполняет, т.к. массив `$_SESSION["arBasketItemsFinal"]` в это время ещё пустой.
2) OnSaleBasketSaved. В обработчике этого события мы получаем актуальный список товаров с их ценниками и количеством. 
Формируем массив `$_SESSION["arBasketItemsFinal"]` (Назовём эту операцию "Действие 1")
3) OnGetOptimalPrice для каждого товара в корзине. Срабатывает уже на следующем хите, т.к. после пользовательского действия корзина по сути подгружается ajax-запросом, а это порождает новый хит. Именно поэтому массив arBasketItemsFinal сохраняется в сессии, а не просто в переменной, т.к. необходима его доступность на разных хитах. 
Изменяем ценники товаров на те, которые прописаны в массиве `$_SESSION["arBasketItemsFinal"]`. (Назовём эту операцию "Действие 2")

Пользователь удаляет товар из корзины:
1) OnSaleBasketSaved. Выполняется "Действие 1".
2) OnGetOptimalPrice для каждого товара в корзине. Выполняется "Действие 2".

Пользователь добавляет товар в корзину:
1) OnGetOptimalPrice для добавляемого товара
1) OnSaleBasketSaved. Выполняется "Действие 1".
2) OnGetOptimalPrice для каждого товара в корзине. Выполняется "Действие 2".


#Действие 1

Это обработчик события OnSaleBasketSaved.

##1 Получаем сведения об акции. Для этого написан вспомогательный метод getAction.

Акции хранятся в инфоблоке. Один элемент инфоблока - одна акция. 

Время начала и окончания активности элемента инфоблока - это, соответственно, время начала и окончания действия акции.

Для N и X созданы свойства.

getAction обращается к инфобоку по символьному коду (символьный код хранится в переменной $strActionIBlockCode) и
извлекает весь список элементов. 

Далее из этого списка в цикле отбирается первый попавшийся активный элемент, т.е. проверяется ACTIVE = Y (элемент активен) и
и текущая дата и время лежит между DATE_ACTIVE_FROM и DATE_ACTIVE_TO.

Результат выборки кэшируется. 

Проще конечно было бы сделать фильтрацию по DATE_ACTIVE в GetList и 
не использовать цикл, но в таком случае выборка активного в данный 
момент элемента ("ACTIVE" => "Y", "DATE_ACTIVE" => "Y") не увяжется с кешированием,
а если отказаться от кэширования, то дёргать элемент их инфоблока при каждом 
срабатывании события - слишком затратно по нагрузке.

##2 Получаем список товаров корзины

Формируем два массива

$arBasketItemsOriginal - ключ ProductId , значения - цена еденицы товара и количество 

$arBasketItems - ключ ProductId , значение - цена. Притом массив формируется по принципу: один элемент массива - один экземпляр товара
притом цену для обоих массивов запрашиваем у каталога через GetByIDEx, а не у корзины - это подстраховка на тот случай, если этот обработчик вызывается не 
первый раз и цена была ранее изменена, а нам в данный момент нужно знать именно исходную цену товара

##3 $arBasketItems сортируется по возрастанию цены

##4 Ключевой момент. У первых ceil(count($arBasketItems) / N) товарам в массиве $arBasketItems меняем значение цены на Х

count($arBasketItems) - это суммарное количество товаров в корзине

##5 Объединяем товары обратно в позиции. 

Позиция - это все экземпляры одного товара. Суммируем цены всех товаров позиции и получаем итоговую цену позиции.

##6 Для каждой позиции делим цену позиции на количество товара в позиции.

В итоге в каждой позиции получим среднее арифметическое, которое и будет являться новой ценой товара и использоваться в обработчике OnGetOptimalPrice

Поясню на примере смысл действий 2 - 6.

Путь N = 1 , X = 2. Каждый второй товар продаем по рублю.

У нас есть три позиции:

1 - 3 товара по 100 р.

2 - 4 товара по 200 р.

5 - 6 товаров по 50р.

arBasketItems будет выглядеть схематично так:

100 100 100 | 200 200 200 200 | 50 50 50 50 50 50 

Сортируем по возрастанию цены:

50 50 50 50 50 50 | 100 100 100 | 200 200 200 200

Применяем акцию:

суммарное количество товары в корзине - 13

13 / 2 = 6.5 = 7 с округление в большую сторону

Первые 7 товаров в отсортированном массиве делаем по 1 рублю.

1 1 1 1 1 1 | 1 100 100 | 200 200 200 200

Первая позиця обновила ценники полностью

Вторая затронута частично

Третья, самые дорогие товары, не затронута

Объединяем обратно в позиции:

1 + 1 + 1 + 1 + 1 + 1 = 6 - цена позиции, т.е. сумма цен всех товаров в позиции

1 + 100 + 100 = 201

200 + 200 + 200 + 200 = 800

Среднее арифметическое для каждого товара в позиции

6 / 6 = 1

201 / 3 = 67

800 / 4 = 200

т.е. новый расклад таков: 

1 1 1 1 1 1 | 67 67 67 | 200 200 200 200

понятно, что 67 67 67 равносильно 1 100 100 , просто среднее арифметическое значение нам нужно для удобного использования в OnGetOptimalPrice

##7 Результат складываем в `$_SESSION["arBasketItemsFinal"]`

Этот массив ловим в обработчике OnGetOptimalPrice



#Действие 2

Это обработчик события OnSaleBasketSaved.

Здесь дело техники.

Массив `$_SESSION["arBasketItemsFinal"]` имеет примерный вид:

ключ - productId, значение - новая цена 

OnGetOptimalPrice вызывается для каждого товара. В обработчике нам известен id товара (productId).

Соответвенно, обращамся к нужному элементу массива по ключу:

`$_SESSION["arBasketItemsFinal"][productId]`. 




Файл handlers.php c полным кодом лежит в папке 1а